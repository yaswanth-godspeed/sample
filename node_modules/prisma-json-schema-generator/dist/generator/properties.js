"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "getJSONSchemaProperty", {
    enumerable: true,
    get: function() {
        return getJSONSchemaProperty;
    }
});
const _constants = require("./constants");
const _helpers = require("./helpers");
const _assertions = require("./assertions");
function getJSONSchemaScalar(fieldType) {
    switch(fieldType){
        case "Int":
        case "BigInt":
            return "integer";
        case "DateTime":
        case "Bytes":
        case "String":
            return "string";
        case "Float":
        case "Decimal":
            return "number";
        case "Json":
            return [
                "number",
                "string",
                "boolean",
                "object",
                "array",
                "null"
            ];
        case "Boolean":
            return "boolean";
        default:
            (0, _helpers.assertNever)(fieldType);
    }
}
function getJSONSchemaType(field) {
    const { isList, isRequired } = field;
    const scalarFieldType = (0, _helpers.isScalarType)(field) && !isList ? getJSONSchemaScalar(field.type) : field.isList ? "array" : (0, _helpers.isEnumType)(field) ? "string" : "object";
    const isFieldUnion = Array.isArray(scalarFieldType);
    return isRequired || isList ? scalarFieldType : isFieldUnion ? Array.from(new Set([
        ...scalarFieldType,
        "null"
    ])) : [
        scalarFieldType,
        "null"
    ];
}
function getDefaultValue(field) {
    const fieldDefault = field.default;
    if (!field.hasDefaultValue) {
        return null;
    }
    if (field.kind === "enum") {
        return typeof fieldDefault === "string" ? fieldDefault : null;
    }
    if (!(0, _helpers.isScalarType)(field)) {
        return null;
    }
    switch(field.type){
        case "String":
        case "BigInt":
        case "DateTime":
            return typeof fieldDefault === "string" ? fieldDefault : null;
        case "Int":
        case "Float":
        case "Decimal":
            return typeof fieldDefault === "number" ? fieldDefault : null;
        case "Boolean":
            return typeof fieldDefault === "boolean" ? fieldDefault : null;
        case "Json":
        case "Bytes":
            return null;
        default:
            return (0, _helpers.assertNever)(field.type);
    }
}
function getFormatByDMMFType(fieldType) {
    switch(fieldType){
        case "DateTime":
            return "date-time";
        default:
            return;
    }
}
function getJSONSchemaForPropertyReference(field, { schemaId, persistOriginalType }) {
    const notNullable = field.isRequired || field.isList;
    (0, _assertions.assertFieldTypeIsString)(field.type);
    const typeRef = `${_constants.DEFINITIONS_ROOT}${field.type}`;
    const ref = {
        $ref: schemaId ? `${schemaId}${typeRef}` : typeRef
    };
    return notNullable ? ref : {
        anyOf: [
            ref,
            {
                type: "null"
            }
        ],
        ...persistOriginalType && {
            originalType: field.type
        }
    };
}
function getItemsByDMMFType(field, transformOptions) {
    return (0, _helpers.isScalarType)(field) && !field.isList || (0, _helpers.isEnumType)(field) ? undefined : (0, _helpers.isScalarType)(field) && field.isList ? {
        type: getJSONSchemaScalar(field.type)
    } : getJSONSchemaForPropertyReference(field, transformOptions);
}
function isSingleReference(field) {
    return !(0, _helpers.isScalarType)(field) && !field.isList && !(0, _helpers.isEnumType)(field);
}
function getEnumListByDMMFType(modelMetaData) {
    return (field)=>{
        const enumItem = modelMetaData.enums.find(({ name })=>name === field.type);
        if (!enumItem) return undefined;
        return enumItem.values.map((item)=>item.name);
    };
}
function getDescription(field) {
    return field.documentation;
}
function getPropertyDefinition(modelMetaData, transformOptions, field) {
    const type = getJSONSchemaType(field);
    const format = getFormatByDMMFType(field.type);
    const items = getItemsByDMMFType(field, transformOptions);
    const enumList = getEnumListByDMMFType(modelMetaData)(field);
    const defaultValue = getDefaultValue(field);
    const description = getDescription(field);
    const definition = {
        type,
        ...transformOptions.persistOriginalType && {
            originalType: field.type
        },
        ...(0, _helpers.isDefined)(defaultValue) && {
            default: defaultValue
        },
        ...(0, _helpers.isDefined)(format) && {
            format
        },
        ...(0, _helpers.isDefined)(items) && {
            items
        },
        ...(0, _helpers.isDefined)(enumList) && {
            enum: enumList
        },
        ...(0, _helpers.isDefined)(description) && {
            description
        }
    };
    return definition;
}
function getJSONSchemaProperty(modelMetaData, transformOptions) {
    return (field)=>{
        const propertyMetaData = {
            required: field.isRequired,
            hasDefaultValue: field.hasDefaultValue,
            isScalar: (0, _helpers.isScalarType)(field) || (0, _helpers.isEnumType)(field)
        };
        const property = isSingleReference(field) ? getJSONSchemaForPropertyReference(field, transformOptions) : getPropertyDefinition(modelMetaData, transformOptions, field);
        return [
            field.name,
            property,
            propertyMetaData
        ];
    };
}
