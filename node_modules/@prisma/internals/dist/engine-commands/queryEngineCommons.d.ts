import * as TE from 'fp-ts/TaskEither';
export declare function preliminaryNodeAPIPipeline(options: {
    prismaPath?: string;
}): TE.TaskEither<{
    type: "query-engine-unresolved";
    reason: string;
    error: Error;
} | {
    type: "node-api-not-supported";
    reason: string;
    error: Error;
}, {
    queryEnginePath: string;
}>;
export declare function preliminaryBinaryPipeline(options: {
    prismaPath?: string;
    datamodelPath?: string;
    datamodel?: string;
}): TE.TaskEither<{
    type: "query-engine-unresolved";
    reason: string;
    error: Error;
} | {
    type: "datamodel-write";
    reason: string;
    error: Error;
}, {
    queryEnginePath: string;
    tempDatamodelPath: string;
}>;
export declare function unlinkTempDatamodelPath(options: {
    datamodelPath?: string;
}, tempDatamodelPath: string | undefined): TE.TaskEither<{
    type: string;
    reason: string;
    error: unknown;
}, void>;
export declare const createDebugErrorType: (debug: (formatter: any, ...args: any[]) => void, fnName: string) => ({ type, reason, error }: {
    type: string;
    reason: string;
    error: Error;
}) => void;
export type QueryEngineErrorInit = {
    reason: string;
    message: string;
} & ({
    readonly _tag: 'parsed';
    errorCode?: string;
} | {
    readonly _tag: 'unparsed';
});
export type ParseQueryEngineError = {
    errorOutput: string;
    reason: string;
};
/**
 * Parse the error output of getConfig / getDmmf, which follow the format convention of the query-engine methods.
 */
export declare function parseQueryEngineError({ errorOutput, reason }: ParseQueryEngineError): QueryEngineErrorInit;
