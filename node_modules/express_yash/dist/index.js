"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_CONFIG = exports.CONFIG_FILE_NAME = exports.Type = exports.SourceType = exports.EventSource = void 0;
const core_1 = require("@godspeedsystems/core");
const express_1 = __importDefault(require("express"));
const body_parser_1 = __importDefault(require("body-parser"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const swagger_ui_express_1 = __importDefault(require("swagger-ui-express"));
const api_docs_1 = __importDefault(require("./api-docs"));
class EventSource extends core_1.GSEventSource {
    initClient() {
        return __awaiter(this, void 0, void 0, function* () {
            const app = (0, express_1.default)();
            const { port = 3000, request_body_limit = 50 * 1024 * 1024, file_size_limit = 50 * 1024 * 1024 } = this.config;
            app.use(body_parser_1.default.urlencoded({ extended: true, limit: request_body_limit }));
            app.use(body_parser_1.default.json({ limit: file_size_limit }));
            app.listen(port);
            const eventPath = path_1.default.join(process.cwd(), "/src/events");
            const definitionsPath = path_1.default.join(process.cwd(), "/src/definitions");
            const configpath = path_1.default.join(process.cwd(), "/config");
            (0, api_docs_1.default)(eventPath, definitionsPath, configpath, port)
                .then((schema) => {
                app.use('/api-docs', swagger_ui_express_1.default.serve, swagger_ui_express_1.default.setup(schema));
            })
                .catch((e) => {
                process.exit(1);
            });
            return app;
        });
    }
    subscribeToEvent(eventRoute, eventConfig, processEvent) {
        const routeSplit = eventRoute.split('.');
        const httpMethod = routeSplit[1];
        const endpoint = routeSplit[2].replace(/{(.*?)}/g, ':$1');
        const app = this.client;
        //@ts-ignore
        app[httpMethod](endpoint, (req, res) => __awaiter(this, void 0, void 0, function* () {
            const gsEvent = EventSource.createGSEvent(req, endpoint);
            const status = yield processEvent(gsEvent, eventConfig);
            res
                .status(status.code || 200)
                // if data is a integer, it takes it as statusCode, so explicitly converting it to string
                .send(Number.isInteger(status.data) ? String(status.data) : status.data);
        }));
        return Promise.resolve();
    }
    static createGSEvent(req, endpoint) {
        const reqProp = lodash_1.default.omit(req, [
            '_readableState',
            'socket',
            'client',
            '_parsedUrl',
            'res',
            'app'
        ]);
        const reqHeaders = lodash_1.default.pick(req, ['headers']);
        let data = Object.assign(Object.assign({}, reqProp), reqHeaders);
        const event = new core_1.GSCloudEvent('id', endpoint, new Date(), 'http', '1.0', data, 'REST', new core_1.GSActor('user'), {});
        return event;
    }
}
exports.EventSource = EventSource;
const SourceType = 'ES';
exports.SourceType = SourceType;
const Type = 'express'; // this is the loader file of the plugin, So the final loader file will be `types/${Type.js}`
exports.Type = Type;
const CONFIG_FILE_NAME = 'http'; // in case of event source, this also works as event identifier, and in case of datasource works as datasource name
exports.CONFIG_FILE_NAME = CONFIG_FILE_NAME;
const DEFAULT_CONFIG = { port: 3000 };
exports.DEFAULT_CONFIG = DEFAULT_CONFIG;
//# sourceMappingURL=index.js.map