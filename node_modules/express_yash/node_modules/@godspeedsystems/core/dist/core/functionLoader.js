"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGSFunction = void 0;
const interfaces_1 = require("./interfaces");
const utils_1 = require("./utils");
const yamlLoader_1 = __importDefault(require("./yamlLoader"));
const codeLoader_1 = __importDefault(require("./codeLoader"));
const logger_1 = require("../logger");
const path_1 = __importDefault(require("path"));
let lastIfFn;
function createGSFunction(workflowJson, workflows, nativeFunctions, onError) {
    var _a, _b, _c;
    logger_1.logger.debug('Creating GSFunction %s workflow_name %s', workflowJson.id, workflowJson.workflow_name);
    if (!workflowJson.fn) {
        if (Array.isArray(workflowJson)) {
            // @ts-ignore
            workflowJson = { tasks: workflowJson, fn: 'com.gs.sequential', workflow_name: workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.workflow_name };
        }
        else {
            workflowJson.fn = 'com.gs.sequential';
        }
    }
    let tasks;
    switch (workflowJson.fn) {
        case 'com.gs.sequential':
            tasks =
                workflowJson
                    .tasks
                    .map((taskJson) => {
                    taskJson.workflow_name = workflowJson.workflow_name;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
            tasks = tasks.filter(Boolean);
            return new interfaces_1.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
        case 'com.gs.dynamic_fn':
            tasks =
                workflowJson
                    .tasks
                    .map((taskJson) => {
                    taskJson.workflow_name = workflowJson.workflow_name;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
            tasks = tasks.filter(Boolean);
            return new interfaces_1.GSDynamicFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
        case 'com.gs.parallel':
            tasks =
                workflowJson
                    .tasks
                    .map((taskJson) => {
                    taskJson.workflow_name = workflowJson.workflow_name;
                    return createGSFunction(taskJson, workflows, nativeFunctions, onError);
                });
            tasks = tasks.filter(Boolean);
            return new interfaces_1.GSParallelFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
        case 'com.gs.switch': {
            let args = [workflowJson.value];
            let cases = {};
            for (let c in workflowJson.cases) {
                workflowJson.cases[c].workflow_name = workflowJson.workflow_name;
                cases[c] = createGSFunction(workflowJson.cases[c], workflows, nativeFunctions, onError);
            }
            if (workflowJson.defaults) {
                workflowJson.defaults.workflow_name = workflowJson.workflow_name;
                cases.default = createGSFunction(workflowJson.defaults, workflows, nativeFunctions, onError);
            }
            args.push(cases);
            logger_1.logger.debug('loading switch workflow %o', workflowJson.cases);
            return new interfaces_1.GSSwitchFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
        }
        case 'com.gs.if': {
            let args = [workflowJson.condition];
            tasks = workflowJson
                .tasks
                .map((taskJson) => {
                taskJson.workflow_name = workflowJson.workflow_name;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            let task = new interfaces_1.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
            args.push(task);
            lastIfFn = new interfaces_1.GSIFFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
            return lastIfFn;
        }
        case 'com.gs.elif': {
            let args = [workflowJson.condition];
            tasks = workflowJson
                .tasks
                .map((taskJson) => {
                taskJson.workflow_name = workflowJson.workflow_name;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            let task = new interfaces_1.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
            args.push(task);
            let fn = new interfaces_1.GSIFFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
            if (!lastIfFn) {
                logger_1.logger.error(`If is missing before elsif ${workflowJson.id}.`);
                throw new Error(`If is missing before elsif ${workflowJson.id}.`);
            }
            else {
                lastIfFn.else_fn = fn;
            }
            lastIfFn = fn;
            return null;
        }
        case 'com.gs.else': {
            tasks = workflowJson
                .tasks
                .map((taskJson) => {
                taskJson.workflow_name = workflowJson.workflow_name;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            let task = new interfaces_1.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
            if (!lastIfFn) {
                logger_1.logger.error(`If is missing before else ${workflowJson.id}.`);
                throw new Error(`If is missing before else ${workflowJson.id}.`);
            }
            else {
                lastIfFn.else_fn = task;
            }
            lastIfFn = null;
            return null;
        }
        case 'com.gs.each_parallel': {
            let args = [workflowJson.value];
            let tasks = workflowJson
                .tasks
                .map((taskJson) => {
                taskJson.workflow_name = workflowJson.workflow_name;
                taskJson.isEachParallel = true;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            let task = new interfaces_1.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
            args.push(task);
            if ((_a = workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.on_error) === null || _a === void 0 ? void 0 : _a.tasks) {
                workflowJson.on_error.tasks.workflow_name = workflowJson.workflow_name;
                workflowJson.on_error.tasks = createGSFunction(workflowJson.on_error.tasks, workflows, nativeFunctions, null);
            }
            logger_1.logger.debug('loading each parallel workflow %o', workflowJson.tasks);
            return new interfaces_1.GSEachParallelFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
        }
        case 'com.gs.each_sequential': {
            let args = [workflowJson.value];
            let tasks = workflowJson
                .tasks
                .map((taskJson) => {
                taskJson.workflow_name = workflowJson.workflow_name;
                return createGSFunction(taskJson, workflows, nativeFunctions, onError);
            });
            tasks = tasks.filter(Boolean);
            let task = new interfaces_1.GSSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, tasks, false);
            args.push(task);
            if ((_b = workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.on_error) === null || _b === void 0 ? void 0 : _b.tasks) {
                workflowJson.on_error.tasks.workflow_name = workflowJson.workflow_name;
                workflowJson.on_error.tasks = createGSFunction(workflowJson.on_error.tasks, workflows, nativeFunctions, null);
            }
            logger_1.logger.debug('loading each sequential workflow %o', workflowJson.tasks);
            return new interfaces_1.GSEachSeriesFunction(workflowJson, workflows, nativeFunctions, undefined, args, false);
        }
    }
    let subwf = false;
    let fn;
    let fnScript;
    if (workflowJson.fn.match(/<(.*?)%/) && workflowJson.fn.includes('%>')) {
        fnScript = (0, utils_1.compileScript)(workflowJson.fn);
    }
    else {
        // Load the fn for this GSFunction
        logger_1.logger.debug('workflowJson.fn %s', workflowJson.fn);
        // first check if it's a native function
        // but, special handling for datasource function, because
        // while using datasource fn: in workflows, it is in this format, `datasource.{datasourceName}.{entityName}.{method}`
        // where as, datasource function are registered as `datasource.{datasourceName}`
        let fnName = String(workflowJson.fn).startsWith('datasource.')
            ?
                String(workflowJson.fn).split('.').splice(0, 2).join('.')
            :
                workflowJson.fn;
        fn = nativeFunctions[fnName];
        if (!fn) { // If not a native function, it should be a GSFunction/Json
            const existingWorkflowData = workflows[fnName];
            if (!existingWorkflowData) {
                throw new Error(`Function specified by name ${fnName} not found in src/functions. Please ensure a function by this path exists.`);
            }
            subwf = true;
            if (!(existingWorkflowData instanceof interfaces_1.GSFunction)) { //Is still a Json data, not converted to GSFunction
                existingWorkflowData.workflow_name = fnName;
                fn = workflows[fnName] = createGSFunction(existingWorkflowData, workflows, nativeFunctions, onError);
            }
            else { //Is a GSFunction already
                fn = existingWorkflowData;
            }
        }
    }
    if ((_c = workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.on_error) === null || _c === void 0 ? void 0 : _c.tasks) {
        workflowJson.on_error.tasks.workflow_name = workflowJson.workflow_name;
        workflowJson.on_error.tasks = createGSFunction(workflowJson.on_error.tasks, workflows, nativeFunctions, null);
    }
    else if (workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.on_error) {
        // do nothing
    }
    else if (onError) {
        workflowJson.on_error = onError;
    }
    if (workflowJson === null || workflowJson === void 0 ? void 0 : workflowJson.authz) {
        workflowJson.authz.workflow_name = workflowJson.workflow_name;
        workflowJson.authz = createGSFunction(workflowJson.authz, workflows, nativeFunctions, onError);
    }
    return new interfaces_1.GSFunction(workflowJson, workflows, nativeFunctions, fn, workflowJson.args, subwf, fnScript);
}
exports.createGSFunction = createGSFunction;
function loadFunctions(datasources, pathString) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let code = yield (0, codeLoader_1.default)(path_1.default.resolve(__dirname, '../functions'));
        let functions = yield (0, yamlLoader_1.default)(pathString);
        let loadFnStatus;
        logger_1.logger.debug('functions %s', Object.keys(functions));
        logger_1.logger.debug('_datasourceFunctions %o', Object.keys(datasources));
        let _datasourceFunctions = Object
            .keys(datasources)
            .reduce((acc, dsName) => {
            // @ts-ignore
            // dsName, eg., httpbin, mongo, prostgres, salesforce
            acc[`datasource.${dsName}`] = (ctx, args) => __awaiter(this, void 0, void 0, function* () {
                return datasources[dsName].execute(ctx, args);
            });
            return acc;
        }, {});
        code = Object.assign(Object.assign({}, code), _datasourceFunctions);
        for (let f in functions) {
            try {
                if (!functions[f].tasks) {
                    throw new Error(`Error in loading tasks of function ${f}.`);
                }
            }
            catch (ex) {
                ex.message = `Error in loading tasks of function ${f}.` + ex.message;
                throw ex;
            }
            const checkDS = (0, utils_1.checkDatasource)(functions[f], datasources);
            if (!checkDS.success) {
                throw new Error(`Error in loading datasource for function ${f} . Error message: ${checkDS.message}. Exiting.`);
            }
        }
        logger_1.logger.debug('Creating workflows: %s', Object.keys(functions));
        for (let f in functions) {
            if (!(functions[f] instanceof interfaces_1.GSFunction)) {
                functions[f].workflow_name = f;
                if ((_a = functions[f].on_error) === null || _a === void 0 ? void 0 : _a.tasks) {
                    functions[f].on_error.tasks.workflow_name = f;
                    functions[f].on_error.tasks = createGSFunction(functions[f].on_error.tasks, functions, code, null);
                }
                functions[f] = createGSFunction(functions[f], functions, code, functions[f].on_error);
            }
        }
        loadFnStatus = { success: true, functions: functions };
        logger_1.logger.info('Loaded workflows: %s', Object.keys(functions));
        return loadFnStatus;
    });
}
exports.default = loadFunctions;
//# sourceMappingURL=functionLoader.js.map