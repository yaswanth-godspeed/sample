import { CHANNEL_TYPE, ACTOR_TYPE, EVENT_TYPE, PlainObject } from './common';
import pino from 'pino';
/**
  * SPEC:
  * Lender's integration:
  * YAML workflow spec
  * project scaffolding
  * API schema spec (includes channel integration)
  * runtime interfaces
  *
  * DEV:
  * dev: runtime engine (execute workflow and includes adapters for different channels)
  * dev: telemetry
  * dev: special functions:
  *  http
  *  transformation
  *
  * Parallel:
  *   GS_data
  */
/**
 * About hooks:
 *
 * LOG EVENT HANDLING (including error)
 * OPTION A:
 *  Whether error happens or not, it can return multiple GSEvents of type: error, warning,
 *  debug, info. On error, the called Function MUST itself handle error internally.
 *  These events will be logged by the common code. If there is an event with error,
 *  the common code will straightaway jump to the finally block.
 * OPTION B:
 *  Dev logs all events himself within the function. And if there is an error,
 *  return GSError (preferred), or throw the error for default handling.
 *  On catching an error, the common code will straightaway jump to the finally block.
 *
 *
 *  NO RETURN (Or any return will be ignored)
 *  If a hook needs subsequent hooks or _function to read any data calculated by it,
 *  it must set that data as per the expected key in ctx.{private | shared}, for the subsequent
 *  logic to consume it. If it returns anything, it will be ignored and not passed to subsequent hooks.
 *
 */
export declare class GSFunction extends Function {
    yaml: PlainObject;
    id: string;
    args?: any;
    args_script?: Function;
    fn?: Function;
    onError?: PlainObject;
    retry?: PlainObject;
    isSubWorkflow?: boolean;
    logs?: PlainObject;
    metrics?: [PlainObject];
    workflow_name?: string;
    workflows: PlainObject;
    nativeFunctions: PlainObject;
    fnScript?: Function;
    caching?: Function;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean, fnScript?: Function);
    _internalCall(ctx: GSContext, taskValue: any): Promise<GSStatus>;
    _observability(ctx: GSContext, taskValue: any): Promise<GSStatus>;
    _executefn(ctx: GSContext, taskValue: any): Promise<GSStatus>;
    handleError(ctx: GSContext, status: GSStatus, taskValue: any): Promise<GSStatus>;
    /**
     *
     * @param instruction
     * @param ctx
     */
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSSeriesFunction extends GSFunction {
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSDynamicFunction extends GSFunction {
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSParallelFunction extends GSFunction {
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSSwitchFunction extends GSFunction {
    condition_script?: Function;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSIFFunction extends GSFunction {
    condition_script?: Function;
    task?: GSFunction;
    else_fn?: GSFunction;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSEachParallelFunction extends GSFunction {
    value_script?: Function;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
export declare class GSEachSeriesFunction extends GSFunction {
    value_script?: Function;
    constructor(yaml: PlainObject, workflows: PlainObject, nativeFunctions: PlainObject, _fn?: Function, args?: any, isSubWorkflow?: boolean);
    _call(ctx: GSContext, taskValue: any): Promise<GSStatus>;
}
/**
 * Final outcome of GSFunction execution.
 */
export declare class GSStatus {
    success: boolean;
    code?: number;
    message?: string;
    data?: any;
    headers?: {
        [key: string]: any;
    };
    constructor(success?: boolean, code?: number, message?: string, data?: any, headers?: {
        [key: string]: any;
    });
}
export declare class GSCloudEvent {
    id: string;
    time: Date;
    specversion: string;
    type: string;
    source: string;
    channel: CHANNEL_TYPE;
    actor: GSActor;
    data: PlainObject;
    metadata?: {
        telemetry?: object;
    };
    constructor(id: string, type: string, time: Date, source: string, specversion: string, data: object, channel: CHANNEL_TYPE, actor: GSActor, metadata: any);
    cloneWithNewData(data: PlainObject): GSCloudEvent;
}
/**
 * __actor (alias to __event.actor), __vars, __config, __src, __modules, __env, __event, __res (starting from the first parent span), __args (of the running GS instruction)
 */
export declare class GSContext {
    inputs: GSCloudEvent;
    outputs: {
        [key: string]: GSStatus;
    };
    log_events: GSLogEvent[];
    config: PlainObject;
    datasources: PlainObject;
    mappings: any;
    plugins: PlainObject;
    exitWithStatus?: GSStatus;
    logger: pino.Logger;
    childLogger: pino.Logger;
    constructor(config: PlainObject, datasources: PlainObject, event: GSCloudEvent, mappings: any, plugins: PlainObject, logger: pino.Logger, childLogger: pino.Logger);
    cloneWithNewData(data: PlainObject): GSContext;
    addLogEvent(event: GSLogEvent): void;
}
/**
 *
 * Basic event information.this
 */
export declare class GSLogEvent {
    type: EVENT_TYPE;
    data: any;
    timestamp: Date;
    attributes: object;
    constructor(type: EVENT_TYPE, data: any, attributes?: object, timestamp?: Date);
}
export declare class GSActor {
    type: ACTOR_TYPE;
    tenant_id?: string;
    name?: string;
    id?: string;
    data?: PlainObject;
    constructor(type: ACTOR_TYPE, tenant_id?: string, name?: string, id?: string, data?: PlainObject);
}
/**
 *
 * Final ResponseStructure
 */
export interface GSResponse {
    apiVersion?: string;
    context?: string;
    id?: string;
    method?: string;
    data?: {
        kind?: string;
        fields?: string;
        etag?: string;
        id?: string;
        lang?: string;
        updated?: string;
        deleted?: boolean;
        currentItemCount?: number;
        itemsPerPage?: number;
        startIndex?: number;
        totalItems?: number;
        pageIndex?: number;
        totalPages?: number;
        pageLinkTemplate?: number;
        next?: PlainObject;
        nextLink?: string;
        previous?: PlainObject;
        previousLink?: string;
        self?: PlainObject;
        selfLink?: string;
        edit?: PlainObject;
        editLink?: string;
        items?: PlainObject[];
    };
    error?: {
        code?: number;
        message?: string;
        errors?: {
            domain?: string;
            reason?: string;
            message?: string;
            location?: string;
            locationType?: string;
            extendedHelp?: string;
            sendReport?: string;
        }[];
    };
}
/**
 * Thoughts on telemetry as middleware
 * Baed on telemetry requirements execute (GSFunction, ctx) call must create a span for itself in the ctx object
 * In the finally clause, the microservice or servler should add a hook on all Instruction it wants to trace.
 * Whether to create span for this instruction or not, will be included in the instruction export configuration.
 * Refer: https://docs.mindgrep.com/docs/scaffolding/intro#common-middleware-in-case-of-microservice
 */
/**
 *We have only events. Every http request is also an event.
* Event processor will process the workflow for the event.
* Every event can have multiple workflows attached to them.
* The workflow will execute and create the response.
* Then the adapter will send the response to one or more events on the channels
* specified in the API shema, with the response data & metadata.
 */ 
