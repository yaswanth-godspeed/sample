"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeNulls = exports.checkFunctionExists = exports.compileScript = exports.prepareScript = exports.checkDatasource = exports.setAtPath = exports.getAtPath = exports.isPlainObject = void 0;
const interfaces_1 = require("./interfaces"); // eslint-disable-line
const coffeescript_1 = __importDefault(require("coffeescript"));
const config_1 = __importDefault(require("config"));
const fs = __importStar(require("fs"));
const assert = __importStar(require("assert"));
const buffer = __importStar(require("buffer"));
const child_process = __importStar(require("child_process"));
const cluster = __importStar(require("cluster"));
const dgram = __importStar(require("dgram"));
const dns = __importStar(require("dns"));
const events = __importStar(require("events"));
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const net = __importStar(require("net"));
const os = __importStar(require("os"));
const path = __importStar(require("path"));
const querystring = __importStar(require("querystring"));
const readline = __importStar(require("readline"));
const stream = __importStar(require("stream"));
const string_decoder = __importStar(require("string_decoder"));
const timers = __importStar(require("timers"));
const tls = __importStar(require("tls"));
const url = __importStar(require("url"));
const util = __importStar(require("util"));
const zlib = __importStar(require("zlib"));
const logger_1 = require("../logger");
const isPlainObject = (value) => (value === null || value === void 0 ? void 0 : value.constructor) === Object;
exports.isPlainObject = isPlainObject;
//like Lodash _.get method
function getAtPath(obj, path) {
    const keys = path.split('.');
    for (const key of keys) {
        if (key in obj) { //obj[key]
            obj = obj[key];
        }
        else {
            return undefined;
        }
    }
    return obj;
}
exports.getAtPath = getAtPath;
//like Lodash _.set method
function setAtPath(o, path, value) {
    const keys = path.split('.');
    let obj = o;
    //prepare the array to ensure that there is nested PlainObject till the last key
    //Ensure there is an PlainObject as value till the second last key
    for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        if (key in obj) { //obj[key]
            obj = obj[key];
        }
        else {
            obj = (obj[key] = {});
        }
    }
    const lastKey = keys[keys.length - 1];
    obj[lastKey] = value;
}
exports.setAtPath = setAtPath;
function checkDatasource(workflowJson, datasources) {
    for (let task of workflowJson.tasks) {
        if (task.tasks) {
            const status = checkDatasource(task, datasources);
        }
        else {
            if (task.fn.includes('datasource.')) {
                /*
                  for eg., in workflow tasks,
                  any task can point to datasource as below
                  ...
                    fn: datasource.mongo.Post.findMany
                    or
                    fn: datasource.redis.get
                  ...
        
                  So, the `mongo`or `redis` in the previous example, is the name actual datasource, whereas `datasource`is just the namespace
                  to differentiate from com.gs functions.
                  While loading the workflows, we only check for the available datasource name, in loaded datasource
                  and rest is handled by the actual datasource implementation.
                */
                const dsName = task.fn.split('.')[1];
                if (!(dsName in datasources)) {
                    logger_1.logger.error('datasource %s is not present in datasources', dsName);
                    const message = `datasource ${dsName} is not present in datasources`;
                    return new interfaces_1.GSStatus(false, 500, message);
                }
            }
        }
    }
    return new interfaces_1.GSStatus(true, undefined);
}
exports.checkDatasource = checkDatasource;
function prepareScript(str) {
    //@ts-ignore
    global.fs = fs;
    //@ts-ignore
    global.assert = assert;
    //@ts-ignore
    global.buffer = buffer;
    //@ts-ignore
    global.child_process = child_process;
    //@ts-ignore
    global.cluster = cluster;
    //@ts-ignore
    global.dgram = dgram;
    //@ts-ignore
    global.dns = dns;
    //@ts-ignore
    global.events = events;
    //@ts-ignore
    global.http = http;
    //@ts-ignore
    global.https = https;
    //@ts-ignore
    global.net = net;
    //@ts-ignore
    global.os = os;
    //@ts-ignore
    global.path = path;
    //@ts-ignore
    global.querystring = querystring;
    //@ts-ignore
    global.readline = readline;
    //@ts-ignore
    global.stream = stream;
    //@ts-ignore
    global.string_decoder = string_decoder;
    //@ts-ignore
    global.timers = timers;
    //@ts-ignore
    global.tls = tls;
    //@ts-ignore
    global.url = url;
    //@ts-ignore
    global.util = util;
    //@ts-ignore
    global.zlib = zlib;
    //@ts-ignore
    let lang = config_1.default.lang || 'coffee';
    let langs = (/<(.*?)%/).exec(str);
    //@ts-ignore
    lang = langs[1] || config_1.default.lang || 'coffee';
    str = str.trim();
    if (str.match(/^<(.*?)%/) && str.match(/%>$/)) {
        let temp = str.replace(/^<(.*?)%/, '').replace(/%>$/, '');
        if (!temp.includes('%>')) {
            str = temp;
        }
    }
    if (str.match(/<(.*?)%/) && str.match(/%>/)) {
        str = "'" + str.replace(/<(.*?)%/g, "' + ").replace(/%>/g, " + '") + "'";
    }
    logger_1.logger.debug('lang: %s', lang);
    logger_1.logger.debug('script: %s', str);
    str = str.trim();
    const initialStr = str;
    if (!/\breturn\b/.test(str)) {
        str = 'return ' + str;
    }
    if (lang === 'coffee') {
        str = coffeescript_1.default.compile(str, { bare: true });
    }
    let prepareScriptFunction;
    try {
        prepareScriptFunction = Function('config', 'inputs', 'outputs', 'mappings', 'task_value', str);
    }
    catch (err) {
        logger_1.logger.error('Caught exception in script compilation, script: %s', initialStr);
        logger_1.logger.error('exception: %o', err.stack);
        process.exit(1);
    }
    return prepareScriptFunction;
}
exports.prepareScript = prepareScript;
function compileScript(args) {
    if (!args) {
        return () => args;
    }
    if (typeof (args) == 'object') {
        if ((0, exports.isPlainObject)(args)) {
            let out = {};
            for (let k in args) {
                out[k] = compileScript(args[k]);
            }
            return function (config, inputs, outputs, mappings, task_value) {
                let returnObj = {};
                for (let k in out) {
                    if (out[k] instanceof Function) {
                        returnObj[k] = out[k](config, inputs, outputs, mappings, task_value);
                    }
                }
                return returnObj;
            };
        }
        else if (Array.isArray(args)) {
            let out = [];
            for (let k in args) {
                out[k] = compileScript(args[k]);
            }
            return function (config, inputs, outputs, mappings, task_value) {
                let returnObj = [];
                for (let k in out) {
                    if (out[k] instanceof Function) {
                        returnObj.push(out[k](config, inputs, outputs, mappings, task_value));
                    }
                    else {
                        returnObj.push(out[k]);
                    }
                }
                return returnObj;
            };
        }
        else {
            return () => args;
        }
    }
    else if (typeof (args) == 'string') {
        if (args.match(/(^|\/):([^/]+)/)) {
            logger_1.logger.debug('before replacing path params %s', args);
            args = args.replace(/(^|\/):([^/]+)/g, '$1<%inputs.params.$2%>');
            logger_1.logger.debug('after replacing path params %s', args);
        }
        if (args.match(/<(.*?)%/) && args.includes('%>')) {
            return prepareScript(args);
        }
    }
    return () => args;
}
exports.compileScript = compileScript;
function checkFunctionExists(events, functions) {
    logger_1.logger.info('Functions %o', Object.keys(functions));
    for (let event in events) {
        if (!(events[event].fn in functions)) {
            logger_1.logger.error('function %s of event %s is not present in functions', events[event].fn, event);
            const msg = `function ${events[event].fn} of event ${event} is not present in functions`;
            return new interfaces_1.GSStatus(false, 500, msg);
        }
    }
    return new interfaces_1.GSStatus(true, undefined);
}
exports.checkFunctionExists = checkFunctionExists;
function removeNulls(obj) {
    const isArray = Array.isArray(obj);
    for (const k of Object.keys(obj)) {
        if (obj[k] === null) {
            if (isArray) {
                //@ts-ignore
                obj.splice(k, 1);
            }
            else {
                delete obj[k];
            }
        }
        else if (typeof obj[k] === "object") {
            removeNulls(obj[k]);
        }
        //@ts-ignore
        if (isArray && obj.length === k) {
            removeNulls(obj);
        }
    }
    return obj;
}
exports.removeNulls = removeNulls;
//# sourceMappingURL=utils.js.map