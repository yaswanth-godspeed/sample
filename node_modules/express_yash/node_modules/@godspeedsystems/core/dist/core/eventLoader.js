"use strict";
/*
 * You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
 * Â© 2022 Mindgrep Technologies Pvt Ltd
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const yamlLoader_1 = __importDefault(require("./yamlLoader"));
const jsonSchemaValidation_1 = require("./jsonSchemaValidation");
const expandVariables_1 = __importDefault(require("./expandVariables"));
const logger_1 = require("../logger");
const rewiteRefsToAbsolutePath = (events) => {
    if (!Object.keys(events).length) {
        // there are no events
        return;
    }
    // deep copy
    logger_1.logger.debug('Replacing $refs in events with definitions.');
    const deepCopyOfEvents = JSON.parse(JSON.stringify(events));
    return Object.keys(deepCopyOfEvents).reduce((accumulator, eventKey) => {
        var _a, _b, _c, _d, _e;
        let eventObject = deepCopyOfEvents[eventKey];
        logger_1.logger.debug('eventObject %o', eventObject);
        const bodyContent = ((_a = eventObject === null || eventObject === void 0 ? void 0 : eventObject.body) === null || _a === void 0 ? void 0 : _a.content) || ((_c = (_b = eventObject === null || eventObject === void 0 ? void 0 : eventObject.data) === null || _b === void 0 ? void 0 : _b.body) === null || _c === void 0 ? void 0 : _c.content);
        if (bodyContent) {
            Object.keys(bodyContent).forEach((contentType) => {
                let contentSchema = bodyContent[contentType].schema;
                if (contentSchema) {
                    if (contentSchema.hasOwnProperty('$ref')) {
                        const defKey = contentSchema.$ref;
                        contentSchema.$ref =
                            'https://godspeed.systems/definitions.json' + defKey;
                        bodyContent[contentType].schema = contentSchema;
                    }
                }
            });
        }
        const responses = (eventObject === null || eventObject === void 0 ? void 0 : eventObject.responses) || ((_e = (_d = eventObject === null || eventObject === void 0 ? void 0 : eventObject.data) === null || _d === void 0 ? void 0 : _d.schema) === null || _e === void 0 ? void 0 : _e.responses);
        logger_1.logger.debug('responses %o', responses);
        if (responses) {
            Object.keys(responses).forEach((responseCode) => {
                let responseContent = responses[responseCode].content;
                logger_1.logger.debug('responseContent %o', responseContent);
                if (responseContent) {
                    Object.keys(responseContent).forEach((responseContentType) => {
                        let responseContentTypeSchema = responseContent[responseContentType].schema;
                        if (responseContentTypeSchema) {
                            if (responseContentTypeSchema.hasOwnProperty('$ref')) {
                                const defKey = responseContentTypeSchema.$ref;
                                responseContentTypeSchema.$ref =
                                    'https://godspeed.systems/definitions.json' + defKey;
                                responses[responseCode].content[responseContentType].schema =
                                    responseContentTypeSchema;
                            }
                        }
                    });
                }
            });
        }
        accumulator[eventKey] = eventObject;
        return accumulator;
    }, {});
};
function loadEvents(functions, pathString) {
    return __awaiter(this, void 0, void 0, function* () {
        const events = yield (0, yamlLoader_1.default)(pathString, true);
        logger_1.logger.debug('events %o', events);
        const evalEvents = (0, expandVariables_1.default)(rewiteRefsToAbsolutePath(events));
        const checkFn = (0, utils_1.checkFunctionExists)(events, functions);
        if (!checkFn.success) {
            logger_1.logger.error('Error in loading functions for events. Error message: %s. Exiting.', checkFn.message);
            process.exit(1);
        }
        yield (0, jsonSchemaValidation_1.loadJsonSchemaForEvents)(evalEvents);
        return evalEvents;
    });
}
exports.default = loadEvents;
//# sourceMappingURL=eventLoader.js.map