"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GSContext = exports.GSStatus = exports.GSCloudEvent = exports.GSActor = exports.GSDataSource = exports.GSEventSource = void 0;
const path_1 = require("path");
const process_1 = require("process");
// loaders
const definitionsLoader_1 = __importDefault(require("./core/definitionsLoader"));
const datasourceLoader_1 = __importDefault(require("./core/datasourceLoader"));
const eventsourceLoader_1 = __importDefault(require("./core/eventsourceLoader"));
const functionLoader_1 = __importDefault(require("./core/functionLoader"));
const eventLoader_1 = __importDefault(require("./core/eventLoader"));
// interfaces
const interfaces_1 = require("./core/interfaces");
Object.defineProperty(exports, "GSActor", { enumerable: true, get: function () { return interfaces_1.GSActor; } });
Object.defineProperty(exports, "GSCloudEvent", { enumerable: true, get: function () { return interfaces_1.GSCloudEvent; } });
Object.defineProperty(exports, "GSContext", { enumerable: true, get: function () { return interfaces_1.GSContext; } });
Object.defineProperty(exports, "GSStatus", { enumerable: true, get: function () { return interfaces_1.GSStatus; } });
const sources_1 = require("./core/_interfaces/sources");
Object.defineProperty(exports, "GSDataSource", { enumerable: true, get: function () { return sources_1.GSDataSource; } });
Object.defineProperty(exports, "GSEventSource", { enumerable: true, get: function () { return sources_1.GSEventSource; } });
// validators
const jsonSchemaValidation_1 = require("./core/jsonSchemaValidation");
const logger_1 = require("./logger");
class Godspeed {
    constructor(params = {}) {
        this.datasources = {};
        this.eventsources = {};
        this.workflows = {};
        this.eventsConfig = {};
        this.definitions = {};
        this.config = {};
        // let's assume we a re getting the current directory, where module is imported
        const currentDir = (0, process_1.cwd)();
        // destruct GodspeedParams, if not supplied, assign the default value
        let { eventsFolderPath, workflowsFolderPath, definitionsFolderPath, configFolderPath, datasourcesFolderPath, eventsourcesFolderPath } = params;
        eventsFolderPath = (0, path_1.join)(currentDir, params.eventsFolderPath || '/src/events');
        workflowsFolderPath = (0, path_1.join)(currentDir, params.workflowsFolderPath || '/src/functions');
        definitionsFolderPath = (0, path_1.join)(currentDir, params.definitionsFolderPath || '/src/definitions');
        configFolderPath = (0, path_1.join)(currentDir, params.configFolderPath || '/config');
        datasourcesFolderPath = (0, path_1.join)(currentDir, params.datasourcesFolderPath || '/src/datasources');
        eventsourcesFolderPath = (0, path_1.join)(currentDir, params.eventsourcesFolderPath || '/src/eventsources');
        this.folderPaths = {
            events: eventsFolderPath,
            workflows: workflowsFolderPath,
            config: configFolderPath,
            definitions: definitionsFolderPath,
            datasources: datasourcesFolderPath,
            eventsources: eventsourcesFolderPath
        };
        Object.freeze(this.folderPaths);
    }
    initilize() {
        this._loadDefinitions()
            .then((definitions) => __awaiter(this, void 0, void 0, function* () {
            this.definitions = definitions;
            let datasources = yield this._loadDatasources();
            this.datasources = datasources;
            let functions = yield this._loadFunctions();
            this.workflows = functions;
            let eventsources = yield this._loadEventsources();
            this.eventsources = eventsources;
            let events = yield this._loadEvents();
            this.eventsConfig = events;
            yield this.subscribeToEvents();
            let status = Object.keys(eventsources).map((esName) => {
                let es = eventsources[esName];
                return `${es.config.type}: ${es.config.port}`;
            }).join(' ');
            logger_1.logger.info(`Your godspeed server is up and running on ${status}.`);
        }))
            .catch((error) => {
            logger_1.logger.error(error);
        });
    }
    _loadEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info('[START] Load Events from %s', this.folderPaths.events);
            let events = yield (0, eventLoader_1.default)(this.workflows, this.folderPaths.events);
            logger_1.logger.debug('Events %o', events);
            logger_1.logger.info('[END] Load Events');
            return events;
        });
    }
    ;
    _loadDefinitions() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info('[START] Load definitions from %s', this.folderPaths.definitions);
            const definitions = yield (0, definitionsLoader_1.default)(this.folderPaths.definitions);
            logger_1.logger.debug('Definitions %o', definitions);
            logger_1.logger.info('[END] Load definitions');
            return definitions;
        });
    }
    _loadFunctions() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info('[START] Load functions from %s', this.folderPaths.workflows);
            const loadFnStatus = yield (0, functionLoader_1.default)(this.datasources, this.folderPaths.workflows);
            logger_1.logger.debug('Functions %o', Object.keys(loadFnStatus.functions));
            if (loadFnStatus.success) {
                logger_1.logger.info('[END] Load Functions');
                return loadFnStatus.functions;
            }
            else {
                throw new Error(`Failed to load functions and workflows.`);
            }
        });
    }
    _loadDatasources() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info('[START] Load Datasources from %s', this.folderPaths.datasources);
            let datasources = yield (0, datasourceLoader_1.default)(this.folderPaths.datasources);
            logger_1.logger.debug('Datasources %o', datasources);
            logger_1.logger.info('[END] Load Datasources');
            return datasources;
        });
    }
    ;
    _loadEventsources() {
        return __awaiter(this, void 0, void 0, function* () {
            logger_1.logger.info('[START] Load Eventsources from %s', this.folderPaths.eventsources);
            let eventsources = yield (0, eventsourceLoader_1.default)(this.folderPaths.eventsources, this.datasources);
            logger_1.logger.debug('Eventsources %o', eventsources);
            logger_1.logger.info('[END] Load Eventsources.');
            return eventsources;
        });
    }
    ;
    subscribeToEvents() {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                for (var _d = true, _e = __asyncValues(Object.keys(this.eventsConfig)), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        let route = _c;
                        let eventKey = route;
                        let eventSourceName = route.split('.')[0];
                        const eventSource = this.eventsources[eventSourceName];
                        const processEventHandler = yield this.processEvent(this);
                        yield eventSource.subscribeToEvent(route, this.eventsConfig[eventKey], processEventHandler);
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    processEvent(local) {
        return __awaiter(this, void 0, void 0, function* () {
            const { workflows, datasources } = local;
            return (event, eventConfig) => __awaiter(this, void 0, void 0, function* () {
                // TODO: improve child logger initilization
                // initilize child logger
                (0, logger_1.initilizeChildLogger)({});
                // TODO: lot's of logging related steps
                logger_1.childLogger.info('processing event ... %s %o', event.type);
                // TODO: Once the config loader is sorted, fetch the apiVersion from config
                const responseStructure = {
                    apiVersion: '1.0'
                };
                let eventHandlerWorkflow;
                let validateStatus = (0, jsonSchemaValidation_1.validateRequestSchema)(event.type, event, eventConfig);
                let eventSpec = eventConfig;
                if (validateStatus.success === false) {
                    logger_1.childLogger.error('failed to validate request body.', validateStatus);
                    const responseData = {
                        message: 'request validation failed.',
                        error: validateStatus.message,
                        data: validateStatus.data
                    };
                    // if `on_validation_error` is defined in the event, let's execute that
                    if (eventSpec.on_validation_error) {
                        const validationError = Object.assign({ success: false, code: validateStatus.code }, responseData);
                        logger_1.childLogger.error(validationError);
                        event.data = { event: event.data, validation_error: validationError };
                        // A workflow is always a series execution of its tasks. ie., a GSSeriesFunction
                        eventHandlerWorkflow = (workflows[eventSpec.on_validation_error]);
                    }
                    else {
                        return validateStatus;
                    }
                }
                else {
                    logger_1.childLogger.info('Request JSON Schema validated successfully %o', validateStatus);
                    eventHandlerWorkflow = (workflows[eventSpec.fn]);
                }
                const ctx = new interfaces_1.GSContext({}, datasources, event, {}, {}, logger_1.logger, logger_1.childLogger);
                let eventHandlerStatus;
                try {
                    yield eventHandlerWorkflow(ctx);
                    // The final status of the handler workflow is calculated from the last task of the handler workflow (series function)
                    eventHandlerStatus = ctx.outputs[eventHandlerWorkflow.id];
                    logger_1.logger.info('eventHandlerStatus', eventHandlerStatus);
                    if (eventHandlerStatus.success) {
                        // event workflow executed successfully
                        // lets validate the response schema
                        let validateResponseStatus = (0, jsonSchemaValidation_1.validateResponseSchema)(event.type, eventHandlerStatus);
                        if (!validateResponseStatus.success) {
                            logger_1.childLogger.error('Response JSON schema validation failed.');
                            return new interfaces_1.GSStatus(false, 500, 'response validation error', {
                                error: {
                                    message: validateResponseStatus.message,
                                    info: validateResponseStatus.data
                                }
                            });
                        }
                    }
                    return eventHandlerStatus;
                }
                catch (error) {
                    return new interfaces_1.GSStatus(false, 500, `Error in executing handler ${eventSpec.fn} for the event ${event.type} `, error);
                }
            });
        });
    }
    ;
}
;
exports.default = Godspeed;
//# sourceMappingURL=godspeed.js.map