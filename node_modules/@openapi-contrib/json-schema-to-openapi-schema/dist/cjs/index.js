"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_schema_walker_1 = require("json-schema-walker");
const const_js_1 = require("./const.js");
class InvalidTypeError extends Error {
    constructor(message) {
        super(message);
        this.name = 'InvalidTypeError';
        this.message = message;
    }
}
const oasExtensionPrefix = 'x-';
const handleDefinition = (def, schema) => __awaiter(void 0, void 0, void 0, function* () {
    if (typeof def !== 'object') {
        return def;
    }
    const type = def.type;
    if (type) {
        // Walk just the definitions types
        const walker = new json_schema_walker_1.Walker();
        yield walker.loadSchema(Object.assign(Object.assign({ definitions: schema['definitions'] || [] }, def), { $schema: schema['$schema'] }), {
            dereference: true,
            cloneSchema: true,
            dereferenceOptions: {
                dereference: {
                    circular: 'ignore',
                },
            },
        });
        yield walker.walk(convertSchema, walker.vocabularies.DRAFT_07);
        if ('definitions' in walker.rootSchema) {
            delete walker.rootSchema.definitions;
        }
        return walker.rootSchema;
    }
    if (Array.isArray(def)) {
        // if it's an array, we might want to reconstruct the type;
        const typeArr = def;
        const hasNull = typeArr.includes('null');
        if (hasNull) {
            const actualTypes = typeArr.filter((l) => l !== 'null');
            return {
                type: actualTypes.length === 1 ? actualTypes[0] : actualTypes,
                nullable: true,
                // this is incorrect but thats ok, we are in the inbetween phase here
            };
        }
    }
    return def;
});
const convert = (schema, options) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const walker = new json_schema_walker_1.Walker();
    const convertDefs = (_a = options === null || options === void 0 ? void 0 : options.convertUnreferencedDefinitions) !== null && _a !== void 0 ? _a : true;
    yield walker.loadSchema(schema, options);
    yield walker.walk(convertSchema, walker.vocabularies.DRAFT_07);
    // if we want to convert unreferenced definitions, we need to do it iteratively here
    const rootSchema = walker.rootSchema;
    if (convertDefs && (rootSchema === null || rootSchema === void 0 ? void 0 : rootSchema.definitions)) {
        for (const defName in rootSchema.definitions) {
            const def = rootSchema.definitions[defName];
            rootSchema.definitions[defName] = yield handleDefinition(def, schema);
        }
    }
    return rootSchema;
});
function stripIllegalKeywords(schema) {
    if (typeof schema !== 'object') {
        return schema;
    }
    delete schema['$schema'];
    delete schema['$id'];
    if ('id' in schema) {
        delete schema['id'];
    }
    return schema;
}
function convertSchema(schema) {
    if (!schema) {
        return schema;
    }
    schema = stripIllegalKeywords(schema);
    schema = convertTypes(schema);
    schema = rewriteConst(schema);
    schema = convertDependencies(schema);
    schema = convertNullable(schema);
    schema = rewriteIfThenElse(schema);
    schema = rewriteExclusiveMinMax(schema);
    schema = convertExamples(schema);
    if (typeof schema['patternProperties'] === 'object') {
        schema = convertPatternProperties(schema);
    }
    if (schema.type === 'array' && typeof schema.items === 'undefined') {
        schema.items = {};
    }
    // should be called last
    schema = convertIllegalKeywordsAsExtensions(schema);
    return schema;
}
const validTypes = new Set([
    'null',
    'boolean',
    'object',
    'array',
    'number',
    'string',
    'integer',
]);
function validateType(type) {
    if (typeof type === 'object' && !Array.isArray(type)) {
        // Refs are allowed because they fix circular references
        if (type.$ref) {
            return;
        }
        // this is a de-referenced circular ref
        if (type.properties) {
            return;
        }
    }
    const types = Array.isArray(type) ? type : [type];
    types.forEach((type) => {
        if (type && !validTypes.has(type))
            throw new InvalidTypeError('Type "' + type + '" is not a valid type');
    });
}
function convertDependencies(schema) {
    const deps = schema.dependencies;
    if (typeof deps !== 'object') {
        return schema;
    }
    // Turns the dependencies keyword into an allOf of oneOf's
    // "dependencies": {
    // 		"post-office-box": ["street-address"]
    // },
    //
    // becomes
    //
    // "allOf": [
    // 	{
    // 		"oneOf": [
    // 			{"not": {"required": ["post-office-box"]}},
    // 			{"required": ["post-office-box", "street-address"]}
    // 		]
    // 	}
    //
    delete schema['dependencies'];
    if (!Array.isArray(schema.allOf)) {
        schema.allOf = [];
    }
    for (const key in deps) {
        const foo = {
            oneOf: [
                {
                    not: {
                        required: [key],
                    },
                },
                {
                    required: [key, deps[key]].flat(),
                },
            ],
        };
        schema.allOf.push(foo);
    }
    return schema;
}
function convertNullable(schema) {
    for (const key of ['oneOf', 'anyOf']) {
        const schemas = schema[key];
        if (!Array.isArray(schemas)) {
            return schema;
        }
        const hasNullable = schemas.some((item) => item.type === 'null');
        if (!hasNullable) {
            return schema;
        }
        const filtered = schemas.filter((l) => l.type !== 'null');
        for (const schemaEntry of filtered) {
            schemaEntry.nullable = true;
        }
        schema[key] = filtered;
    }
    return schema;
}
function convertTypes(schema) {
    if (typeof schema !== 'object') {
        return schema;
    }
    if (schema.type === undefined) {
        return schema;
    }
    validateType(schema.type);
    if (Array.isArray(schema.type)) {
        if (schema.type.includes('null')) {
            schema.nullable = true;
        }
        const typesWithoutNull = schema.type.filter((type) => type !== 'null');
        if (typesWithoutNull.length === 0) {
            delete schema.type;
        }
        else if (typesWithoutNull.length === 1) {
            schema.type = typesWithoutNull[0];
        }
        else {
            delete schema.type;
            schema.anyOf = typesWithoutNull.map((type) => ({ type }));
        }
    }
    else if (schema.type === 'null') {
        delete schema.type;
        schema.nullable = true;
    }
    return schema;
}
// "patternProperties did not make it into OpenAPI v3.0"
// https://github.com/OAI/OpenAPI-Specification/issues/687
function convertPatternProperties(schema) {
    var _a;
    schema['x-patternProperties'] = schema['patternProperties'];
    delete schema['patternProperties'];
    (_a = schema.additionalProperties) !== null && _a !== void 0 ? _a : (schema.additionalProperties = true);
    return schema;
}
// keywords (or property names) that are not recognized within OAS3 are rewritten into extensions.
function convertIllegalKeywordsAsExtensions(schema) {
    const keys = Object.keys(schema);
    keys
        .filter((keyword) => !keyword.startsWith(oasExtensionPrefix) &&
        !const_js_1.allowedKeywords.includes(keyword))
        .forEach((keyword) => {
        const key = `${oasExtensionPrefix}${keyword}`;
        schema[key] = schema[keyword];
        delete schema[keyword];
    });
    return schema;
}
function convertExamples(schema) {
    if (schema['examples'] && Array.isArray(schema['examples'])) {
        schema['example'] = schema['examples'][0];
        delete schema['examples'];
    }
    return schema;
}
function rewriteConst(schema) {
    if (Object.hasOwnProperty.call(schema, 'const')) {
        schema.enum = [schema.const];
        delete schema.const;
    }
    return schema;
}
function rewriteIfThenElse(schema) {
    if (typeof schema !== 'object') {
        return schema;
    }
    /* @handrews https://github.com/OAI/OpenAPI-Specification/pull/1766#issuecomment-442652805
  if and the *Of keywords

  There is a really easy solution for implementations, which is that

  if: X, then: Y, else: Z

  is equivalent to

  oneOf: [allOf: [X, Y], allOf: [not: X, Z]]
  */
    if ('if' in schema && schema.if && schema.then) {
        schema.oneOf = [
            { allOf: [schema.if, schema.then].filter(Boolean) },
            { allOf: [{ not: schema.if }, schema.else].filter(Boolean) },
        ];
        delete schema.if;
        delete schema.then;
        delete schema.else;
    }
    return schema;
}
function rewriteExclusiveMinMax(schema) {
    if (typeof schema.exclusiveMaximum === 'number') {
        schema.maximum = schema.exclusiveMaximum;
        schema.exclusiveMaximum = true;
    }
    if (typeof schema.exclusiveMinimum === 'number') {
        schema.minimum = schema.exclusiveMinimum;
        schema.exclusiveMinimum = true;
    }
    return schema;
}
exports.default = convert;
//# sourceMappingURL=index.js.map