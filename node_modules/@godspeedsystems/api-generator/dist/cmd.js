"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const internals_1 = require("@prisma/internals");
const cli_select_1 = __importDefault(require("cli-select"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const prisma_1 = __importDefault(require("./utils/prisma"));
const elasticgraph_1 = __importDefault(require("./utils/elasticgraph"));
const transformDMMF_1 = require("prisma-json-schema-generator/dist/generator/transformDMMF");
const findDatasources_1 = __importDefault(require("./helpers/findDatasources"));
const glob_1 = require("glob");
const toml = __importStar(require("toml"));
const writeFileSafely_1 = require("./utils/writeFileSafely");
const jsYaml = require('js-yaml');
const chalk = require('chalk');
const getUserResponseFromCLI = async (eligibleDatasources) => {
    console.log(chalk.white('Select datasource / schema to generate CRUD APIs'));
    let { value: selectedDatasource } = await (0, cli_select_1.default)({
        values: [
            ...eligibleDatasources,
            { dsName: 'For all', dsFilePath: '' },
            { dsName: 'Cancel', dsFilePath: '' },
        ],
        valueRenderer: (value, selected) => {
            if (selected) {
                return value.dsName === 'Cancel'
                    ? chalk.red(value.dsName)
                    : chalk.blue(value.dsName);
            }
            else {
                return value.dsName;
            }
        },
    });
    return { selectedDatasource, allDatasources: eligibleDatasources };
};
const invokeGenerationForPrismaDS = async ({ dsName, dsFilePath, }) => {
    const samplePrismaSchema = (0, internals_1.getSchemaSync)(dsFilePath);
    let dmmf = await (0, internals_1.getDMMF)({
        datamodel: samplePrismaSchema,
    });
    const jsonSchema = (0, transformDMMF_1.transformDMMF)(dmmf, {
        keepRelationScalarFields: 'true',
    });
    let basePathForGeneration = './src';
    let defs = {};
    const setDefs = (def) => {
        defs = { ...defs, ...def };
    };
    dmmf.datamodel.models.forEach(async (modelInfo) => {
        await prisma_1.default.eventGen({
            basePathForGeneration,
            modelName: modelInfo.name,
            dataSourceName: (dsName || '').replace('.prisma', ''),
            modelFields: modelInfo.fields,
            jsonSchema,
        }, setDefs);
        const METHODS = ['one', 'create', 'update', 'delete', 'search'];
        METHODS.map(async (method) => {
            await prisma_1.default.workflowGen({
                basePathForGeneration,
                modelName: modelInfo.name,
                dataSourceName: (dsName || '').replace('.prisma', ''),
                modelFields: modelInfo.fields,
                method,
            });
        });
    });
    (0, writeFileSafely_1.writeFileSafely)(`./src/definitions/${(dsName || '').replace('.prisma', '')}.yaml`, jsYaml.dump(defs));
    console.log(chalk.green(`Events and Workflows are generated for ${dsName}`));
};
const invokeGenerationForElasticgraphDS = async ({ dsName, dsFilePath, dsType, dsConfig, }) => {
    const { schema_backend } = dsConfig;
    let basePathForGeneration = './src';
    try {
        (0, glob_1.glob)(schema_backend + '/schema/entities/*.toml', (err, entityFiles) => {
            let entities = entityFiles.reduce((acc, filepath) => {
                let entityName = filepath
                    .substring(filepath.lastIndexOf('/') + 1)
                    .replace('.toml', '');
                try {
                    let fileContent = fs_1.default.readFileSync(filepath, { encoding: 'utf-8' });
                    let parsedToml = toml.parse(fileContent);
                    parsedToml = JSON.parse(JSON.stringify(parsedToml));
                    acc[entityName] = parsedToml;
                }
                catch (error) {
                    console.error(error);
                }
                return acc;
            }, {});
            Object.keys(entities).forEach(async (entityKey) => {
                await elasticgraph_1.default.eventGen({
                    basePathForGeneration,
                    dataSourceName: (dsName || '').replace(/(.yml|.yaml)/, ''),
                    entityName: entityKey,
                    entityFields: entities[entityKey],
                });
                const METHODS = ['create', 'update', 'delete', 'search'];
                METHODS.map(async (method) => {
                    await elasticgraph_1.default.workflowGen({
                        basePathForGeneration,
                        dataSourceName: (dsName || '').replace(/(.yml|.yaml)/, ''),
                        entityName: entityKey,
                        entityFields: entities[entityKey],
                    }, method);
                });
            });
        });
        console.log(chalk.green(`Events and Workflows are generated for ${dsName}`));
    }
    catch (error) {
        console.error('Error while reading the schema_backend.');
    }
};
const generateCrudAPIs = async () => {
    try {
        let datasourceDir = path_1.default.join(process.cwd(), 'src', 'datasources');
        let eligibleDatasources = await (0, findDatasources_1.default)(datasourceDir);
        let { selectedDatasource, allDatasources } = await getUserResponseFromCLI(eligibleDatasources);
        if (selectedDatasource.dsName === 'For all') {
            allDatasources.map(async (dsDefinition) => {
                if (selectedDatasource.dsType === 'prisma') {
                    await invokeGenerationForPrismaDS(dsDefinition);
                }
                else {
                    console.error('No mechanism is defined to handle this kinda schema.');
                }
            });
        }
        else if (selectedDatasource.dsName === 'Cancel') {
            throw Error('Auto API generation canceled.');
        }
        else {
            if (selectedDatasource.dsType === 'prisma') {
                await invokeGenerationForPrismaDS(selectedDatasource);
            }
            else if (selectedDatasource.dsType === 'elasticgraph') {
                await invokeGenerationForElasticgraphDS(selectedDatasource);
            }
            else {
                console.error("No mechanism is defined to generate API's from this kinda schema.");
            }
        }
    }
    catch (error) {
        throw error;
    }
};
generateCrudAPIs().catch((error) => {
    console.log(chalk.red(error));
});
//# sourceMappingURL=cmd.js.map