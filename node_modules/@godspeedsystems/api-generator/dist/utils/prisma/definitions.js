"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDefinitionsFile = void 0;
const assert_1 = __importDefault(require("assert"));
const replaceValuesByRegx_1 = __importDefault(require("../../helpers/replaceValuesByRegx"));
const event_1 = require("./event");
const generateDefinitionsFile = (dsName, modelName, jsonSchema, modelFields) => {
    var _a;
    let indexField = (0, event_1.findIndexField)(modelFields);
    (0, assert_1.default)(jsonSchema, `There is no valid jsonSchema present for ${dsName}.`);
    let definitions = jsonSchema.definitions;
    (0, assert_1.default)(definitions, `There is no valid definitions present in jsonSchema.`);
    let modelDefinition = definitions[modelName];
    (0, assert_1.default)(modelDefinition && typeof modelDefinition !== 'boolean', `Definition is undefined or boolean(unsupported) for ${modelName}`);
    let sanitizedProperties = Object.keys((_a = modelDefinition.properties) !== null && _a !== void 0 ? _a : {}).reduce((accumulator, propertyName) => {
        (0, assert_1.default)(typeof modelDefinition !== 'boolean', `Definition of type boolean unsupported`);
        if (typeof modelDefinition.properties !== 'undefined') {
            let property = modelDefinition.properties[propertyName];
            let _prop = {};
            (0, assert_1.default)(typeof property !== 'boolean', 'Property of type boolean unsupported');
            if (property.type === 'array') {
                if (property.items && property.items.hasOwnProperty('$ref')) {
                    return accumulator;
                }
            }
            if (property.hasOwnProperty('$ref')) {
                return accumulator;
            }
            if (property.hasOwnProperty('anyOf') ||
                property.hasOwnProperty('allOf') ||
                property.hasOwnProperty('oneOf')) {
                let _ = property.anyOf || property.allOf || property.oneOf;
                (0, assert_1.default)(_, 'anyOf/allOf/oneOf not defined');
                let refCount = _.filter((obj) => {
                    return obj.hasOwnProperty('$ref') ? true : false;
                }).length;
                if (refCount) {
                    return accumulator;
                }
            }
            if (Array.isArray(property.type)) {
                if (property.type.length === 2) {
                    _prop['nullable'] = true;
                    _prop['type'] = property.type[0];
                }
                if (property.type.length === 6) {
                    _prop['nullable'] = true;
                    _prop['type'] = 'object';
                }
                property = {
                    ...property,
                    ..._prop,
                };
            }
            accumulator[propertyName] = property;
            return accumulator;
        }
    }, {});
    const { id, ...rest } = sanitizedProperties;
    let _defs = {};
    _defs[modelName] = {
        type: 'object',
        properties: rest,
    };
    return (0, replaceValuesByRegx_1.default)(_defs, /^(#\/definitions\/)(.*)/i, `$1${dsName}/$2`);
};
exports.generateDefinitionsFile = generateDefinitionsFile;
//# sourceMappingURL=definitions.js.map