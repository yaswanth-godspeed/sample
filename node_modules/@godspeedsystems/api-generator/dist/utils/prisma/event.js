"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAndStoreEvent = exports.findIndexField = void 0;
const generateWriteLocationForMethod_1 = require("../generateWriteLocationForMethod");
const writeFileSafely_1 = require("../writeFileSafely");
const definitions_1 = require("./definitions");
const jsYaml = require('js-yaml');
const findIndexField = (modelFields) => {
    let indexField = modelFields.find(({ isId }) => isId);
    return indexField;
};
exports.findIndexField = findIndexField;
const generateEventKey = ({ dataSourceName, modelName, modelFields }, method) => {
    let indexField = (0, exports.findIndexField)(modelFields);
    switch (method) {
        case 'one':
            return `http.get./${dataSourceName.toLowerCase()}/${modelName.toLowerCase()}/{${indexField === null || indexField === void 0 ? void 0 : indexField.name}}`;
        case 'create':
            return `http.post./${dataSourceName.toLowerCase()}/${modelName.toLowerCase()}`;
        case 'update':
            return `http.put./${dataSourceName.toLowerCase()}/${modelName.toLowerCase()}/{${indexField === null || indexField === void 0 ? void 0 : indexField.name}}`;
        case 'delete':
            return `http.delete./${dataSourceName.toLowerCase()}/${modelName.toLowerCase()}/{${indexField === null || indexField === void 0 ? void 0 : indexField.name}}`;
        case 'search':
            return `http.post./${dataSourceName.toLowerCase()}/${modelName.toLowerCase()}/search`;
        default:
            return '';
    }
};
const generateSummaryBasedOnModelAndMethod = (modelName, method) => {
    switch (method) {
        case 'one':
            return `Fetch ${modelName}`;
        case 'create':
            return `Create a new ${modelName}`;
        case 'update':
            return `Update a ${modelName}`;
        case 'delete':
            return `Delete a ${modelName}`;
        case 'search':
            return `Fetch multiple ${modelName}`;
        default:
            return '';
    }
};
const generateDescriptionBasedOnModelAndMethod = (modelName, method) => {
    switch (method) {
        case 'one':
            return `Fetch ${modelName} from database`;
        case 'create':
            return `Create ${modelName} from database`;
        case 'update':
            return `Update ${modelName} from database`;
        case 'delete':
            return `Delete ${modelName} from database`;
        case 'search':
            return `Fetch multiple ${modelName} from database`;
        default:
            return '';
    }
};
const _generateBodyAndParamsFromJsonSchema = (method, modelName, jsonSchema, modelFields, dataSourceName) => {
    let indexField = (0, exports.findIndexField)(modelFields);
    return {
        body: method === 'create' || method === 'update'
            ? {
                content: {
                    'application/json': {
                        schema: {
                            $ref: `#/definitions/${dataSourceName}/${modelName}`,
                        },
                    },
                },
            }
            : method === 'search'
                ? {
                    content: {
                        'application/json': {
                            schema: {
                                type: 'object'
                            },
                        },
                    },
                }
                : undefined,
        params: method !== 'create' && method !== 'search'
            ? [
                {
                    name: indexField ? indexField.name : '',
                    in: 'path',
                    required: true,
                    schema: { type: 'string' },
                },
            ]
            : undefined,
    };
};
const generateFn = (method, modelName, dataSourceName) => {
    return `com.biz.${dataSourceName.toLowerCase()}.${modelName.toLowerCase()}.${method}`;
};
const generateResponses = (method) => {
    if (method === 'search') {
        return {
            content: {
                'application/json': {
                    schema: {
                        type: 'array',
                    },
                },
            },
        };
    }
    else {
        return {
            content: {
                'application/json': {
                    schema: {
                        type: 'object',
                    },
                },
            },
        };
    }
};
const generateEvent = (eventConfig) => {
    let json = {};
    let { dataSourceName, modelName, method, modelFields, jsonSchema } = eventConfig;
    let eventKey = generateEventKey({
        dataSourceName: dataSourceName,
        modelName: modelName,
        modelFields: modelFields,
    }, method);
    let summary = generateSummaryBasedOnModelAndMethod(modelName, method);
    let description = generateDescriptionBasedOnModelAndMethod(modelName, method);
    let fn = generateFn(method, modelName, dataSourceName);
    let bodyAndParams = {};
    try {
        let { body, params } = _generateBodyAndParamsFromJsonSchema(method, modelName, jsonSchema, modelFields, dataSourceName);
        bodyAndParams = { body, params };
    }
    catch (error) {
        console.warn(error);
    }
    let responses = generateResponses(method);
    json.eventKey = eventKey;
    json.structure = {
        summary,
        description,
        fn,
        ...bodyAndParams,
        responses,
    };
    return json;
};
const generateAndStoreEvent = async (eventConfig, setDefs) => {
    const { basePathForGeneration, dataSourceName, modelName, modelFields, jsonSchema, } = eventConfig;
    const METHODS = ['one', 'create', 'update', 'delete', 'search'];
    let _defs = (0, definitions_1.generateDefinitionsFile)(dataSourceName, modelName, jsonSchema, modelFields);
    setDefs(_defs);
    let consolidateJsonForEvent = METHODS.map((method) => {
        let content = `# ${method.toUpperCase()}\r\n`;
        let { eventKey, structure } = generateEvent({ ...eventConfig, method });
        content = content + `${jsYaml.dump({ [eventKey]: structure })}\r\n`;
        return content;
    }).join('');
    const writeLocation = (0, generateWriteLocationForMethod_1.generateWriteLocationForMethod)(basePathForGeneration, '/events', dataSourceName, modelName.toLowerCase());
    await (0, writeFileSafely_1.writeFileSafely)(writeLocation, consolidateJsonForEvent);
    return 'Generated all events';
};
exports.generateAndStoreEvent = generateAndStoreEvent;
//# sourceMappingURL=event.js.map