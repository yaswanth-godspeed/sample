"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAndStoreEvent = void 0;
const generateWriteLocationForMethod_1 = require("../generateWriteLocationForMethod");
const writeFileSafely_1 = require("../writeFileSafely");
const jsYaml = require('js-yaml');
const genEventKey = (dataSourceName, entityName, method) => {
    switch (method) {
        case 'one':
            return `http.get./${dataSourceName.toLowerCase()}/${entityName.toLowerCase()}/:id`;
        case 'create':
            return `http.post./${dataSourceName.toLowerCase()}/${entityName.toLowerCase()}`;
        case 'update':
            return `http.put./${dataSourceName.toLowerCase()}/${entityName.toLowerCase()}`;
        case 'delete':
            return `http.delete./${dataSourceName.toLowerCase()}/${entityName.toLowerCase()}`;
        case 'search':
            return `http.post./${dataSourceName.toLowerCase()}/${entityName.toLowerCase()}/search`;
        default:
            return '';
    }
};
const genEventSummary = (entityName, method) => {
    switch (method) {
        case 'one':
            return `Fetch ${entityName}`;
        case 'create':
            return `Create a new ${entityName}`;
        case 'update':
            return `Update a ${entityName}`;
        case 'delete':
            return `Delete a ${entityName}`;
        case 'search':
            return `Fetch multiple ${entityName}`;
        default:
            return '';
    }
};
const genEventDescription = (entityName, method) => {
    switch (method) {
        case 'one':
            return `Fetch ${entityName} from elasticgraph`;
        case 'create':
            return `Create ${entityName} from elasticgraph`;
        case 'update':
            return `Update ${entityName} from elasticgraph`;
        case 'delete':
            return `Delete ${entityName} from elasticgraph`;
        case 'search':
            return `Fetch multiple ${entityName} from elasticgraph`;
        default:
            return '';
    }
};
const genEventFunction = (method, entityName, dataSourceName) => {
    return `com.eg.${dataSourceName.toLowerCase()}.${entityName.toLowerCase()}.${method}`;
};
const processEntityObject = (entityFields) => {
    return Object.keys(entityFields).reduce((accumulator, fieldKey) => {
        let field = entityFields[fieldKey];
        let oasCompatibleFieldDescriptor = {
            type: !Array.isArray(field.type)
                ? field.type.toLowerCase() === 'date'
                    ? 'string'
                    : field.type.toLowerCase()
                : [field.type[0].toLowerCase()],
            ...(!Array.isArray(field.type) &&
                field.type.toLowerCase() === 'date' && { format: 'date-time' }),
        };
        accumulator[fieldKey] = {
            ...oasCompatibleFieldDescriptor,
        };
        return accumulator;
    }, {});
};
const genBodyAndParams = (method, entityFields) => {
    return {
        body: {
            content: {
                'application/json': {
                    schema: {
                        type: 'object',
                        properties: {
                            ...((method === 'delete' ||
                                method === 'update' ||
                                method === 'one') && {
                                id: {
                                    type: 'string',
                                },
                            }),
                            ...((method === 'update' || method === 'create') && {
                                data: {
                                    type: 'object',
                                    properties: { ...processEntityObject(entityFields) },
                                },
                            }),
                            ...(method === 'search' && {
                                query: {
                                    type: 'object',
                                },
                                from: {
                                    type: 'number',
                                },
                                size: {
                                    type: 'number',
                                },
                            }),
                        },
                    },
                },
            },
        },
    };
};
const genResponses = (method) => {
    if (method === 'search') {
        return {
            content: {
                'application/json': {
                    schema: {
                        type: 'array',
                    },
                },
            },
        };
    }
    else {
        return {
            content: {
                'application/json': {
                    schema: {
                        type: 'object',
                    },
                },
            },
        };
    }
};
const generateEvent = (eventConfig) => {
    let json = {};
    let { dataSourceName, entityName, entityFields, method } = eventConfig;
    let eventKey = genEventKey(dataSourceName, entityName, method);
    let summary = genEventSummary(entityName, method);
    let description = genEventDescription(entityName, method);
    let fn = genEventFunction(method, entityName, dataSourceName);
    let responses = genResponses(method);
    let { body } = genBodyAndParams(method, entityFields);
    json.eventKey = eventKey;
    json.structure = {
        summary,
        description,
        fn,
        body,
        responses,
    };
    return json;
};
const generateAndStoreEvent = async (eventConfig) => {
    let json = {};
    let { basePathForGeneration, dataSourceName, entityName, entityFields } = eventConfig;
    const METHODS = ['create', 'update', 'delete', 'search'];
    let consolidateJsonForEvent = METHODS.map((method) => {
        let content = `# ${method.toUpperCase()}\r\n`;
        let { eventKey, structure } = generateEvent({ ...eventConfig, method });
        content = content + `${jsYaml.dump({ [eventKey]: structure })}\r\n`;
        return content;
    }).join('');
    const writeLocation = (0, generateWriteLocationForMethod_1.generateWriteLocationForMethod)(basePathForGeneration, '/events', dataSourceName, entityName.toLowerCase());
    await (0, writeFileSafely_1.writeFileSafely)(writeLocation, consolidateJsonForEvent);
    return 'Generated all events';
};
exports.generateAndStoreEvent = generateAndStoreEvent;
//# sourceMappingURL=event.js.map