/*
* You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
* Â© 2022 Mindgrep Technologies Pvt Ltd
*/
'use strict';
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const build = require('pino-abstract-transport');
const { SonicBoom } = require('sonic-boom');
const { once } = require('events');
const DEFAULT_MESSAGE_KEY = 'msg';
const ZEROS_FROM_MILLI_TO_NANO = '0'.repeat(6);
/**
 * @typedef {Object} CommonBindings
 * @property {string=} msg
 * @property {number=} level
 * @property {number=} time
 * @property {string=} hostname
 * @property {number=} pid
 *
 * @typedef {Record<string, string | number | Object> & CommonBindings} Bindings
 *
 */
/**
 * Pino OpenTelemetry transport
 *
 * Maps Pino log entries to OpenTelemetry Data model
 *
 * @typedef {Object} Options
 * @property {string | number} destination
 * @property {string} [messageKey="msg"]
 *
 * @param {Options} opts
 */
module.exports = function (opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const destination = new SonicBoom({ dest: opts.destination, sync: false });
        const mapperOptions = {
            messageKey: opts.messageKey || DEFAULT_MESSAGE_KEY
        };
        const resourceOptions = Object.assign({}, opts.Resource);
        return build(function (/** @type { AsyncIterable<Bindings> } */ source) {
            var _a, source_1, source_1_1;
            var _b, e_1, _c, _d;
            var _e, _f;
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    for (_a = true, source_1 = __asyncValues(source); source_1_1 = yield source_1.next(), _b = source_1_1.done, !_b;) {
                        _d = source_1_1.value;
                        _a = false;
                        try {
                            const obj = _d;
                            const line = toOpenTelemetry(obj, mapperOptions, resourceOptions);
                            let updatedLine;
                            if (process.env.NODE_ENV != 'dev') {
                                updatedLine = JSON.stringify(line) + '\n';
                            }
                            else {
                                let timestamp = parseInt(line.Timestamp.replace(ZEROS_FROM_MILLI_TO_NANO, ''));
                                let date = new Date(timestamp);
                                let dateString = new Intl.DateTimeFormat('en-IN', { dateStyle: 'short', timeStyle: 'medium', timeZone: 'Asia/Kolkata' }).format(date);
                                updatedLine = `${dateString} [${line.SeverityText}] ${(_e = line.TraceId) !== null && _e !== void 0 ? _e : ''} ${(_f = line.SpanId) !== null && _f !== void 0 ? _f : ''} ${JSON.stringify(line.Attributes)} ${line.Body}\n`;
                            }
                            const writeResult = destination.write(updatedLine);
                            const toDrain = !writeResult;
                            // This block will handle backpressure
                            if (toDrain) {
                                yield once(destination, 'drain');
                            }
                        }
                        finally {
                            _a = true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_a && !_b && (_c = source_1.return)) yield _c.call(source_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            });
        }, {
            close() {
                return __awaiter(this, void 0, void 0, function* () {
                    destination.end();
                    yield once(destination, 'close');
                });
            }
        });
    });
};
const FATAL_SEVERITY_NUMBER = 21;
/**
 * If the source format has only a single severity that matches the meaning of the range
 * then it is recommended to assign that severity the smallest value of the range.
 * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#mapping-of-severitynumber
 */
const SEVERITY_NUMBER_MAP = {
    10: 1,
    20: 5,
    30: 9,
    40: 13,
    50: 17,
    60: FATAL_SEVERITY_NUMBER
};
// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/data-model.md#displaying-severity
const SEVERITY_NAME_MAP = {
    1: 'TRACE',
    2: 'TRACE2',
    3: 'TRACE3',
    4: 'TRACE4',
    5: 'DEBUG',
    6: 'DEBUG2',
    7: 'DEBUG3',
    8: 'DEBUG4',
    9: 'INFO',
    10: 'INFO2',
    11: 'INFO3',
    12: 'INFO4',
    13: 'WARN',
    14: 'WARN2',
    15: 'WARN3',
    16: 'WARN4',
    17: 'ERROR',
    18: 'ERROR2',
    19: 'ERROR3',
    20: 'ERROR4',
    21: 'FATAL',
    22: 'FATAL2',
    23: 'FATAL3',
    24: 'FATAL4'
};
/**
 * Converts a pino log object to an OpenTelemetry log object.
 *
 * @typedef {Object} OpenTelemetryLogData
 * @property {string=} SeverityText
 * @property {string=} SeverityNumber
 * @property {string} Timestamp
 * @property {string} Body
 * @property {{ 'host.hostname': string, 'process.pid': number }} Resource
 * @property {Record<string, any>} Attributes
 *
 * @typedef {Object} MapperOptions
 * @property {string} messageKey
 *
 * @param {Bindings} sourceObject
 * @param {MapperOptions} mapperOptions
 * @returns {OpenTelemetryLogData}
 */
function toOpenTelemetry(sourceObject, { messageKey }, resourceOptions) {
    const _a = sourceObject, { time, level, hostname, pid, trace_id, span_id, trace_flags } = _a, _b = messageKey, msg = _a[_b], attributes = __rest(_a, ["time", "level", "hostname", "pid", "trace_id", "span_id", "trace_flags", typeof _b === "symbol" ? _b : _b + ""]);
    const severityNumber = SEVERITY_NUMBER_MAP[sourceObject.level];
    const severityText = SEVERITY_NAME_MAP[severityNumber];
    return {
        Body: msg,
        Timestamp: time + ZEROS_FROM_MILLI_TO_NANO,
        SeverityNumber: severityNumber,
        SeverityText: severityText,
        TraceId: trace_id,
        SpanId: span_id,
        TraceFlags: trace_flags,
        Resource: Object.assign(Object.assign({}, resourceOptions), { 'host.hostname': hostname, 'process.pid': pid }),
        Attributes: attributes
    };
}
//# sourceMappingURL=pino-opentelemetry-transport.js.map