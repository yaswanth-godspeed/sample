"use strict";
/*
 * You are allowed to study this software for learning and local * development purposes only. Any other use without explicit permission by Mindgrep, is prohibited.
 * Â© 2022 Mindgrep Technologies Pvt Ltd
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateResponseSchema = exports.validateRequestSchema = exports.loadJsonSchemaForEvents = void 0;
const logger_1 = require("../logger");
const validation_1 = __importStar(require("./validation"));
function loadJsonSchemaForEvents(eventObj) {
    logger_1.logger.debug('Loading JSON Schema for events %s', Object.keys(eventObj));
    logger_1.logger.debug('eventObj: %o', eventObj);
    return new Promise((resolve, reject) => {
        Object.keys(eventObj).forEach(function (topic) {
            var _a, _b, _c, _d, _e, _f;
            // Add body schema in ajv for each content_type per topic
            /* TODO: Right now, we are assuming that there is going to be one content_type only i.e. application/json
                        This needs to be enhanced in fututre when multiple content_type will be supported
                */
            const eventObjTopic = eventObj[topic];
            if ((0, validation_1.isValidEvent)(eventObjTopic, topic)) {
                //Object.keys(eventObjTopic).forEach(function(topic) {
                const body_content = ((_a = eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.body) === null || _a === void 0 ? void 0 : _a.content) || //just like OpenAPI Spec but with body instead of requestBody
                    ((_d = (_c = (_b = eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.data) === null || _b === void 0 ? void 0 : _b.schema) === null || _c === void 0 ? void 0 : _c.body) === null || _d === void 0 ? void 0 : _d.content); //Legacy
                if (body_content) {
                    Object.keys(body_content).forEach(function (k) {
                        const content_schema = body_content[k].schema;
                        if (content_schema) {
                            logger_1.logger.debug('adding body schema for %s', topic);
                            logger_1.logger.debug('content_schema %o', content_schema);
                            if (!validation_1.default.getSchema(topic)) {
                                validation_1.default.addSchema(content_schema, topic);
                            }
                        }
                    });
                }
                // Add params schema in ajv for each param per topic
                const params = (eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.parameters) || (eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.params) || ((_f = (_e = eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.data) === null || _e === void 0 ? void 0 : _e.schema) === null || _f === void 0 ? void 0 : _f.params);
                let paramSchema = {};
                if (params) {
                    for (let param of params) {
                        if (param.schema) {
                            if (!paramSchema[param.in]) {
                                paramSchema[param.in] = {
                                    type: 'object',
                                    required: [],
                                    properties: {},
                                };
                            }
                            if (param.required) {
                                paramSchema[param.in].required.push(param.name);
                            }
                            let schema = param.schema;
                            if (param.allow_empty_value) {
                                param.schema.nullable = true;
                            }
                            paramSchema[param.in].properties[param.name] = schema;
                        }
                    }
                }
                for (let schema in paramSchema) {
                    logger_1.logger.info('adding param schema for %s', topic);
                    logger_1.logger.debug('param schema: %o', paramSchema[schema]);
                    const topic_param = topic + ':' + schema;
                    if (!validation_1.default.getSchema(topic_param)) {
                        validation_1.default.addSchema(paramSchema[schema], topic_param);
                    }
                }
                // Add responses schema in ajv for each response per topic
                const responses = eventObjTopic === null || eventObjTopic === void 0 ? void 0 : eventObjTopic.responses;
                if (responses) {
                    Object.keys(responses).forEach(function (k) {
                        var _a, _b, _c, _d, _e, _f, _g, _h;
                        const response_s = ((_c = (_b = (_a = responses[k]) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b['application/json']) === null || _c === void 0 ? void 0 : _c.schema) || //Exactly as OpenApi spec
                            ((_h = (_g = (_f = (_e = (_d = responses[k]) === null || _d === void 0 ? void 0 : _d.schema) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g['application/json']) === null || _h === void 0 ? void 0 : _h.schema); //Legacy implementation
                        if (response_s) {
                            const response_schema = response_s;
                            const topic_response = topic + ':responses:' + k;
                            //console.log("topic_response: ",topic_response)
                            if (!validation_1.default.getSchema(topic_response)) {
                                validation_1.default.addSchema(response_schema, topic_response);
                            }
                        }
                    });
                }
            }
            else {
                process.exit(1);
            }
        });
        resolve(1);
    });
}
exports.loadJsonSchemaForEvents = loadJsonSchemaForEvents;
/* Function to validate GSCloudEvent */
function validateRequestSchema(topic, event, eventSpec) {
    var _a, _b, _c, _d;
    let status;
    // Validate event.data.body
    const hasSchema = (eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.body) || ((_b = (_a = eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.data) === null || _a === void 0 ? void 0 : _a.schema) === null || _b === void 0 ? void 0 : _b.body);
    if (event.data.body && hasSchema) {
        logger_1.childLogger.info('event body and eventSpec exist');
        logger_1.childLogger.debug('event.data.body: %o', event.data.body);
        const ajv_validate = validation_1.default.getSchema(topic);
        if (ajv_validate) {
            logger_1.childLogger.debug('ajv_validate for body');
            if (!ajv_validate(event.data.body)) {
                logger_1.childLogger.error('ajv_validate failed');
                status = {
                    success: false,
                    code: 400,
                    message: ajv_validate.errors[0].message,
                    data: ajv_validate.errors[0],
                };
                return status;
            }
            else {
                logger_1.childLogger.info('ajv_validate success for body');
                status = { success: true };
            }
        }
        else {
            status = { success: true };
        }
    }
    else if (!event.data.body && hasSchema) {
        status = {
            success: false,
            code: 400,
            message: 'Body not found in request but specified in the event schema',
        };
        return status;
    }
    // } else if ( Object.keys(event.data.body).length && !eventSpec?.data?.schema?.body ) {
    //     status = { success: false, code: 400, message: "Body found in request but not specified in the event schema"}
    //     return status
    // }
    else {
        //Body is not present in request and not specified in the event schema
        status = { success: true };
    }
    const params = (eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.parameters) ||
        (eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.params) || //structure like open api spec
        ((_d = (_c = eventSpec === null || eventSpec === void 0 ? void 0 : eventSpec.data) === null || _c === void 0 ? void 0 : _c.schema) === null || _d === void 0 ? void 0 : _d.params); //Legacy
    // Validate event.data['params']
    let MAP = {
        path: 'params',
        header: 'headers',
        query: 'query',
        cookie: 'cookie',
    };
    logger_1.childLogger.debug('ajv_validate for params');
    if (params) {
        for (let param in MAP) {
            const topic_param = topic + ':' + param;
            const ajv_validate = validation_1.default.getSchema(topic_param);
            logger_1.childLogger.debug('topic_param: %s', topic_param);
            if (ajv_validate) {
                if (!ajv_validate(event.data[MAP[param]])) {
                    ajv_validate.errors[0].message += ' in ' + param;
                    status = {
                        success: false,
                        code: 400,
                        message: ajv_validate.errors[0].message,
                        data: ajv_validate.errors[0],
                    };
                    return status;
                }
                else {
                    logger_1.childLogger.info('ajv_validate success for params');
                    status = { success: true };
                }
            }
        }
    }
    return status;
}
exports.validateRequestSchema = validateRequestSchema;
/* Function to validate GSStatus */
function validateResponseSchema(topic, gs_status) {
    let status;
    //console.log("gs_status: ",gs_status)
    if (gs_status.data) {
        const topic_response = topic + ':responses:' + gs_status.code;
        const ajv_validate = validation_1.default.getSchema(topic_response);
        if (ajv_validate) {
            if (!ajv_validate(gs_status.data)) {
                logger_1.childLogger.error('ajv_validate failed');
                status = {
                    success: false,
                    code: 500,
                    message: ajv_validate.errors[0].message,
                    data: ajv_validate.errors[0],
                };
                return status;
            }
            else {
                logger_1.childLogger.info('ajv_validate success');
                status = { success: true };
            }
        }
        else {
            status = { success: true };
        }
    }
    else {
        status = { success: true };
    }
    return status;
}
exports.validateResponseSchema = validateResponseSchema;
//# sourceMappingURL=jsonSchemaValidation.js.map